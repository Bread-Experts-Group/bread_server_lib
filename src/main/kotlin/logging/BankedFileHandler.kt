package org.bread_experts_group.logging

import org.bread_experts_group.coder.format.huffman.BitInputStream
import org.bread_experts_group.coder.format.huffman.BitOutputStream
import org.bread_experts_group.coder.format.huffman.HuffmanBranch
import org.bread_experts_group.stream.readExtensibleULong
import org.bread_experts_group.stream.writeExtensibleLong
import org.bread_experts_group.stream.writeExtensibleULong
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import java.nio.channels.FileChannel
import java.nio.file.Path
import java.nio.file.StandardOpenOption
import java.text.BreakIterator
import java.text.Normalizer
import java.util.*
import java.util.logging.Handler
import java.util.logging.LogRecord

/**
 * A handler for file-based, banked logging.
 * @author Miko Elbrecht
 * @since 2.32.0
 */
class BankedFileHandler(
	val bankPath: Path,
	val contentPath: Path,
	val timestampPath: Path
) : Handler() {
	@Suppress("LongLine", "SpellCheckingInspection")
	@OptIn(ExperimentalStdlibApi::class)
	companion object {
		val englishHuffman = HuffmanBranch.import(
			"6f1073116e12691374146115200b894080069c048106d2028206ff0283068a058406d1048506d40486068c058706e106880685448906b3048a06e2018b06ee018c06f1018d068d058e06ca028f06fc019006bc059106a7019206cd029306de019406f7039506cb029606ab029706eb029806f4019906ef019a06eb019b06bf039c06d0019d069d049e06c6019f06ca40a006b807a106f601a206fe01a3068b40a406d904a506e104a6068102a706e801a806e701a90621aa062bab06e901ac06d302ad063dae063eaf069205b0068a40b1065fb206e601b3068305b406f001b5069302b60640b706ea04b8063fb906e84fba06e94fbb0658bc0651bd0626be069440bf0624c006db04c106c805c20623c3065ac4063bc506d005c60659c70625c8064bc9066aca064acb0656cc0671cd0657ce0655cf062fd0064cd1064fd20652d30647d40644d5064ed60622d70627d80646d9069340da067adb0678dc0645dd0649de0650df0648e00637e10609e20643e3063ae40636e50638e60635e70639e80654e9064dea0642eb066bec0634ed0633ee0641ef062df00653f10628f20629f3065df4065bf50630f60676f70632f80631f9062efa0677fb0679fc062cfd0662fe0666ff060a70707167726d7375746475687663776c3c723d651f".hexToByteArray()
				.inputStream()
		) to 1
		val japaneseHuffman = HuffmanBranch.import(
			"f5c00180208dfa0181205282209bc201832097d8018420d680028520f09a028620cbf30187208da1018820baf501892092b5018a20abea018b20b380028c20aace018d20cba0028e20fcff018f20b09d029020ac88029120d4cf019220839e029320e9e90194208240952085a6019620ecc50197208793029820cb4b9920a4b7019a20baea019b20b6fe039c2080b8039d20feb0019e20a1bf019f2082ba03a020ba8302a120daf201a220e3ca01a320f8a202a420d49f02a5208eb801a620eaea01a720c5ca01a820e0c501a920ada001aa20d99e01ab208e8602ac20f39e01ad20c79902ae2099cb01af20d0fe03b02094a402b1208a9e01b220f29602b320bfa201b420ebdf01b520c2a801b620dd9c01b720c7ae01b820febc01b920c68102ba20bace01bb20a3ea01bc20e7bb01bd209b9f01be20fdb201bf20ccff01c020ef9b02c120e18802c220848802c320b5e801c420ab6ac520889402c620e5ef01c7209fa002c820aa9c01c92089a501ca20c9a201cb20b2e401cc20b89e01cd20a5da01ce20849a02cf2093be01d020aba001d120e19002d220a7d801d320aba302d42099e101d520e9c801d620d4b602d720abd801d820bda402d920c1d901da20fbf301db20e1a702dc20a1b002dd20e4b801de20cc8102df20e8f201e0209a9302e12099fe03e220cafe03e320dbb102e420deb102e520f09402e620ffa601e720e3a401e820dd9b02e920e7b002ea20aaf501eb20f5a701ec208c8002ed20f2bb01ee20aae401ef20bb40f02071f120d59102f220aeb201f320c09902f420ccb701f52084b801f620e49a02f720dccd01f820d8ab02f9209ffe03fa20efc001fb20adfb01fc20aac101fd20e9b701fe20dfce01ff20a981028021db81028121e390028221e1a00283219dac028421e2ca018521f6a3018621ebbe018721cbb801882186e4018921e7c2018a21a5cc018b21d1a6018c21a0ad028d21c2fa018e21b0d1018f21ca9f019021a0f6019121e6be019221a69c019321bfc4019421a4b0019521cea1029621c5b3029721e69e029821ce9d019921a8b1019a2187b7019b21d6f6019c21f5db019d21fedf019e218291029f21dfe401a0219cc501a121a2dd01a221c59102a321b8a102a421aeb701a521cbaf01a621c4a402a721ee9f01a821d2fb01a921a39402aa21d6cd01ab21bfed01ac21f8a701ad21adc901ae2188db01af21adcb01b021f6fa01b12198a502b221d8c801b321caa002b4218bda01b52192fe03b62181f901b7219160b821daa201b921919e01ba21bdff01bb21e1a901bc219ec501bd21b8b701be21dbb701bf219ebf01c021cbfc01c121889d01c221a19902c321e58502c421cda101c521bd8502c621eff501c721fca002c821b69c01c921ddbb01ca21a8b202cb21cfb602cc21b18502cd21cca302ce21f6ac02cf218bab02d021e9a002d121a0e501d221f2e401d321a4df01d421f78602d52185d101d621dbe401d721efcc01d821a0cf01d921caa801da21fbdb01db21bef301dc21aab201dd21aafe03de21e2a701df2197da01e021bcf201e12182f001e221e9d601e321f19c01e421ce9f02e521d3b301e621d79c01e721bd8802e821e9b001e921fdcd01ea21bce201eb21bee401ec21c5ad02ed21dac701ee21d89102ef21bf9f02f021f5fa01f121b8b801f221f7be01f321ffbe01f421cdc001f521f3a502f621dda302f721cb8902f821bcb602f921878c02fa21bcf101fb21fff401fc21ebe001fd21a3a001fe21f78002ff21a5c7018022ddbe018122e29902822284ab018322d0a2018422a19c018522b6e8018622b095028722f884028822aca3018922e3ab018a22e383028b22b89c018c22e3ad018d22f280028e22bba6018f22e6940290228294029122c1a1029222b1aa019322b182029422e5a002952282b0029622f6bd01972280a0029822e4b6019922dac1019a22eec2019b22dda5019c22b0a4019d228ab8019e22b3a7019f228bbf01a022b0e901a122a2b701a222d7a601a3229e9c01a42291c401a522a6a102a622f6c201a722b3d901a822afaa01a9229d9e02aa229cbd01ab22c69d02ac229fb101ad2281d101ae22f65faf22c9b401b022cae701b1228ef201b2229fcc01b322effb01b422a6fc01b522e88302b622fab701b722e6a301b822819e01b922f4cc01ba228aa301bb22a7cc01bc228ead02bd22b6bd01be22d59d01bf22d4b001c022ffce01c12282af01c222defc01c322f8b701c422cbb903c522fcbc01c622818002c722f4b201c822c8a201c922edf201ca2280a201cb229e9902cc22b39302cd22facc01ce22c5eb01cf22a701d022a4a001d122de9902d222d8bf01d3225fd422b2c301d5228fd801d62278d722f9f501d82291f101d922d1db01da22cebd02db22cbc001dc22e6fa01dd22d8c501de22da8c02df228eba03e022c39c01e122b0bc01e222b2fe03e322e3e601e42285ff01e522feb102e622f2cd01e722daa601e822ebb101e922f49302ea2287f701eb228f9c02ec229060ed22869c01ee22c0b603ef2266f022ddb601f122828602f222c8b201f322a9b901f4229540f522b9b301f622dfb701f722b2f401f8229afa01f922e8c601fa22dead01fb22abbc01fc22fda102fd22a4ff01fe22ceaf01ff22f5bf018023cf9e018123d4b30182238dd2018323598423b3b1018523e0a6018623a0d601872381b8038823ed9502892380dd018a23768b23a7ae018c2397f7018d23bbb0028e23c5a2018f239afb01902397b101912394cc019223e6d6019323dc609423bffb019523cfa3029623d7bf019723f9c4019823b1e3019923deb8019a23c291029b2385a5029c23f3c1019d23aad4019e23a495029f2394a002a023ddf201a12384df01a223e9ae02a323b661a42380ab02a523969f01a623ca9d02a72399a301a823aa9e02a92390aa01aa23e260ab23f7a201ac23c261ad23eefe01ae23a0a301af23a89c01b0239461b123c0b003b22381cd01b323c561b423c19402b523ea9902b623f160b723e3c201b82381b002b923f460ba23f760bb23afc601bc23be61bd23c9f601be23fd60bf238e61c023fb63c12392bf01c223ee61c323f563c423fa60c523d0ba03c62386a002c723e4ba03c823fc63c923ffa002ca23f663cb23f163cc23fd63cd239561ce23fa63cf23f463d023f263d123f063d22383b101d323d29302d423d1ba03d52380ff03d62385ff03d723e5ba03d823fe63d9239661da23f863db23d2ba03dc23e6ba03dd23ff63de23f963df23fb9d01e023f49a02e12398b701e223e9cb01e32393cc01e42384c501e523b8a002e623dbed01e723cffb01e8238da302e92390a302ea23c5a501eb23b0c901ec23d09e01ed23beb801ee239343ef23a6cd01f023bcb002f123a8d101f223b69f01f323bccb01f423a9a401f523979402f623b49902f723c1f301f82388b701f9238bd701fa23cd9e01fb238aa401fc23a19f01fd238fad02fe23dcda01ff23ffcd018024f0f3018124ced701822492a3018324a9d4018424bfac028524f5d201862498be0187248ffe038824cf91028924588a24b49e018b24cba7018c248e96028d249fba038e24c2ae018f24ccb0029024f096029124a2ba039224d5e201932481a0029424a0ba039524dbd701962486b803972483ab019824c4bd029924e5f2019a2486619b2484a2019c24ec609d2494fa019e24b89e029f24e7ba03a0249db701a124f363a224c9b301a324e5bb01a4248a9c02a524dcbf01a6249e61a724fe61a824a3ab02a924cfc701aa24bae101ab249aa701ac24abbd01ad24dcfe03ae246daf24fa61b024eb8c02b124ebb301b2249ba801b324b7ea01b4243fb524d261b62497bf01b7248a9b02b824f28402b924ba9f02ba248e9c01bb24e661bc24969302bd24bea101be24cab001bf24bc61c024d1ad02c1248bf401c224d59e01c324bdcb01c424ed60c5248dbf02c62495bf02c72488c701c824edd201c924e5b902ca24b7d701cb24d060cc24f761cd24e2ad02ce24abb201cf24a4a401d024acdc01d124bdc501d224e3a701d324a2c701d424f861d524d361d624ab9902d724edef01d824c3c701d924b19402da24cec201db24b7a401dc24e6f301dd24db61de24c39f01df2483bc01e024ae61e124bcc501e224f961e3249dbc01e4248ff301e524fbad02e624b9a501e72495c501e8249fc201e92480c501ea2497a601eb2423ec24cea002ed2489a001ee24def201ef249b9602f024e0f501f124f8b601f224c59c01f324b58a02f4248bae01f524e2d901f624c9f701f724f7a002f8249cab01f924e5b801fa2497b701fb2498c701fc2487ed01fd24f0ff01fe24c5bf01ff24d0fa018025ca9d018125fbec0182258cb7018325bba70184259dc0018525fd9f028625de80028725e2cb018825aefc0189254f8a259595028b25b39b028c25899e028d25f5a4018e25e3ad028f25ef84029025d8b5029125d2ff019225c3bd019325ffc4019425ce9e019525d8960296258eff019725f383029825bcd00199258cee019a25f5619b25d69d019c25f6619d2585a3019e25dc619f25f09f02a025e7cb01a12589e701a22599fb01a325d4a601a425eeb101a525c29f01a625f560a725b261a825f0a601a9259ba501aa25e49d01ab25bc9e01ac25a8c701ad25c8d001ae25cd61af25a2fa01b025e99402b125809d01b225f9be01b325d2d101b425e29d02b525a9ba01b625cda202b725e861b8259b61b925f3ea01ba25c2d801bb259c61bc25f4ed01bd2591c501be25c0ee01bf25f763c025c6aa01c125dfd401c225c5c101c325f6fe03c42597a401c525f8ed01c625d6a701c725ac9d01c8259eff03c925f3ef01ca2582d301cb25b6e201cc259afe03cd25d1ce01ce25d4a002cf25d1a802d025c5bc01d125d4d701d225a0a501d325cea701d425e19f01d525f79a02d625bc9402d725e8fb01d8258fb201d925d3a002da25dbad01db25d2ae02dc2585dc01dd25d660de25d061df25c160e025d39002e125c1a901e225a1e201e3259161e425d9be01e525d4b502e6259340e7258fbd01e825f1ce01e925c360ea258561eb25c061ec25ba61ed25b4bf01ee25e2d601ef25d7c501f02547f125debb01f225fad801f325e6bb01f425839c01f525d861f625d7a701f725adcc01f825c560f925d0ac02fa25a561fb258ba001fc259061fd25c760fe258761ff25c960802683e8018126c0c40182269c4083269d4084269d618526fd618626cfa101872682b0018826c795028926cb9c018a26b9b7018b26aee6018c26e7a1018d26d89d018e26fdec018f26a49d019026b7be019126f7db019226df619326d1a3029426dafb0195268ad7019626e5a201972690cf0198268d9c019926f9609a26e2ae029b26729c26c7a4019d26b6a4019e26d1b2019f26f261a026f4a001a126e4ac02a226bc9f02a326b461a426e2ac02a526de60a6268361a72687c601a8268960a926d5a501aa2648ab26abce01ac26c4ad02ad26f2ad01ae26a9a501af2691a801b026a9bf01b1268d9502b226b8c401b326f8a002b426dfd801b526b99c01b626f59e01b72699a101b826a961b926ecc901ba26b1b001bb26dd9f01bc26ce60bd26b6e501be26fc60bf26d260c026cfaa01c12689e801c2268860c3268560c4264cc526f1c401c626c3bf01c72699e301c826e48b02c92682bc01ca26f19402cb26f2a401cc268be701cd2699a001ce26cea302cf26eebb01d026a5c901d126d3af02d226a8ce01d326b7bd01d426f6b901d526a1d001d626eecc01d726ea8302d826b2a602d926f89502da26b9ca01db26e3a002dc2650dd26b0ea01de26c58702df26a9b201e026f3a701e126c7f701e226ffaf02e32683b002e426b3ea01e526fece01e626f18502e726cda302e826929d01e926bef201ea26ef61eb26ece501ec26d5a002ed26adb002ee2697cf01ef26a1c701f026959d01f126feec01f2268f9302f326f1b801f426cda701f52668f626c1da01f72657f826a161f9268baf01fa268bb701fb26f1be01fc2675fd26b0fa01fe26bfca01ff26f1618027f394028127baa60182279a8202832791b8018427efa701852787920286279ccf018727678827fbbb018927d1618a27d6618b27fd91028c27faad018d27beda018e27a7618f27faa0029027bba4019127aa93029227b4d8019327b28102942789a8019527ac61962784fa019727ff92029827cdac02992799c6019a27c1fc019b27f0619c27faf4019d27cdf8019e27dbc7019f27f461a02773a127fd8102a227b160a327d78802a4279fb701a527e8a801a62777a7276ca82762a927e161aa27caa701ab27d1f301ac27bb61ad276aae27b2a002af27d461b027dc9102b127e8ac01b227baf101b327899c01b427e461b527f4ca01b62799d401b727eda201b827ac8402b927a640ba27cfa001bb279cd201bc27cc61bd27fedc01be27c4f701bf27a6f601c027949d01c127c4fa01c227cbb301c327e8a201c427b7ad02c527d5b801c62796dd01c7279fa701c827bd61c92754ca27bb9c01cb27ccea01cc27a1d601cd2784a801ce27a6bd01cf27c1cb01d027d8b601d127f860d227d8d301d327feb701d427f1a201d527a6c401d627cb61d72793bf01d827a0a002d927d69502da27c3a201db27bf9502dc27c361dd27da60de278c9d01df27b161e02774e1274ee22753e3279bad02e427e19b02e527a3a002e627dca601e727bbd901e82793ab02e92795be01ea27dd61eb27b8bc01ec2780ce01ed27deae02ee27a861ef2749f027c1df01f1278b9f01f227e361f327f0a701f427d761f5278fbe01f6279a9e01f72794f001f82785b002f927e19802fa279fee01fb27f6f401fc27e261fd27c6f701fe27c8a302ff27ad9c01c002cf60c102e5cb01c202cd60c302e39d01c402fc61c50239c6022dc702acce01c80234c902fdad01ca029a61cb0233cc02fe60cd02a8ea01ce02e89002cf02c660d0025dd1025bd2028861d3028a61d402d560d502e360d602f3af02d702d360d8028261d902d39e01da02d960db02cb60dc0232dd029e9502de02f8cd01df02ee9d01b0018961b101d760b2018da801b30131b401ea60b50120b6019261b701d7b6015c095de760bc01e660bd01cc60be01ef60bf01e860608c6161826062c46063ee6032df6066eb606789fe03d00188fe03d10130d201c260d3018c60d4018d60d501a2de01d60187cb01d7010a368b616e81606fbbda01800e22810eef8702820ee761830ee9e401840ec961850ee560860e87a401870edfaf01880e9fa001890efaaf018a0ede94028b0e89b7018c0ec1a6018d0ef7da018e0ec7618f0e91d801900ed19f02910e8fae01920e89ce01930e6b940ecfcb01950ede61960ecf61970eccd601980ecbc401990eb0619a0ed79f019b0ed8a6019c0e99619d0ec4619e0eeca2019f0e90dd01a00e81c601a10ef7d201a20eb561a30ecbc201a40ece61a50ed460a60e819302a70ec98802a80e858002a90eaeb702aa0eb2ea01ab0e4bac0e9fae01ad0ea8b502ae0eccfa01af0ed9ca01b00ee7e201b10eb2ab02b20e9ab701b30eed61b40ecaa601b50e8061b60ecbd301b70e44b80ef660b90e9e9f02ba0e939402bb0e70bc0eaba801bd0e83bd01be0ef7aa02bf0ea2ab02c00ed0b601c10ec8e401c20ef4d601c30ee1c501c40ea5a401c50eb5be01c60e8060c70ef260c80eaef401c90ed561ca0ef3ad01cb0e63cc0eaa61cd0eeeed01ce0e9d9e01cf0eb1ea01d00e4ad10e8b9c01d20ee160d30e86e801d40ed860d50e8d61d60ef2a701d70ebbea01d80e879c01d90efb60da0ed961db0ea0fa01dc0eec61dd0ee5ea01de0ead9502df0ec2a701e00ea79302e10ef7a701e20e9243e30eb961e40eacf601e50e838002e60ec6ad02e70ed5d901e80ef1fa01e90e81ee01ea0e8a9c01eb0ef9e401ec0ef3a801ed0ee39302ee0e9da401ef0ec161f00e86b002f10edeb002f20eb5d701f30e6ff40e88ce01f50eb6b701f60ef3b201f70eb0cb01f80ee961f90eda61fa0ea661fb0ea7c001fc0e96b201fd0ec661fe0e9fce01ff0e8b9d01800f8ca901810fad61820fb761830fe561840fd3be01850ff360860fb701870ffaa301880fc0f701890fe5ce018a0facb0038b0fa1f8018c0f258d0fdb608e0fea618f0f9dce01900f2f910faf61920fcda401930fcbf501940f8ca801950f96b302960fe3d601970ffca801980f43990fe0619a0fa3619b0f419c0ffbf9019d0f8b93029e0f649f0fcdd701a00f9aa002a10f90c401a20fc98602a30f28a40f80fa01a50f29a60f5ea70fb361a80fe8d901a90f45aa0ff0ca01ab0fb0ae01ac0f6ead0fb861ae0f65af0f61b00f42b10fbf61b20fc6f601b30fdc9e01b40f9fea01b50fb9e101b60fba9d01b70ffbaf02b80fe6b601b90fb9cb01ba0ff0b101bb0f9ab201bc0f8fb801bd0f969c01be0f9361bf0fbaf201c00ffaec01c10feb61c20f2cc30f8ecc01c40f86a401c50fa8ae01c60f809402c70fff60c80f89b201c90ff8a201ca0fa261cb0f8cbf01cc0f8fc201cd0fa461ce0fe4a701cf0ff0ea01d00fe59d01d10fac9502d20fca61d30fa9ff01d40fe060d50fb4b001d60f96a601d70f2ed80fab61d90fa7b201da0f46db0ff060dc0ffee701dd0f84ed01de0f809c01df0f3ae00f36e10f37e20f69e30fc2cc01e40fc860e50fc861e60f2be70fe2be01e80fd160e90ff361ea0fe8a102eb0f38ec0fcc9002ed0f88a801ee0fc7e401ef0f55f00f8e60f10f8f60f20fe960f30fe460f40fca60f50f35f60fdd60f70f8161f80f8461f90f989402fa0f8f61fb0ffb61fc0ff3bc01fd0fff9e01fe0ff4bc01ff0f".hexToByteArray()
				.inputStream()
		) to 2
		val huffmen = listOf(englishHuffman, japaneseHuffman)

		fun readMemoryBank(bank: FileChannel): MutableList<String> = buildList {
			while (bank.position() < bank.size()) {
				val initialPosition = bank.position()
				val backed = ByteBuffer.allocate(11)
				bank.read(backed)
				val data = backed.array().inputStream()
				val size = data.readExtensibleULong()
				if (size > Int.MAX_VALUE.toUInt())
					throw UnsupportedOperationException("Size is too big! [$size]")
				val compressionMethod = data.read()
				bank.position(initialPosition + (backed.capacity() - data.available()))
				val contentBacked = ByteBuffer.allocate(size.toInt())
				bank.read(contentBacked)
				when (compressionMethod) {
					0 -> add(contentBacked.array().decodeToString())
					else -> {
						huffmen.firstOrNull { (_, type) ->
							type == (compressionMethod and 0b00011111)
						}?.let { (huffman, _) ->
							val unused = compressionMethod shr 5
							val input = BitInputStream(contentBacked.array().inputStream())
							var decoded = ""
							while ((input.available() - unused) > 0) decoded += huffman.next(input)
							add(decoded)
						} ?: throw UnsupportedOperationException("Compression method [$compressionMethod]")
					}
				}
			}
		}.toMutableList()
	}

	val bank: FileChannel = FileChannel.open(
		bankPath,
		StandardOpenOption.WRITE, StandardOpenOption.CREATE,
		StandardOpenOption.READ
	)
	val content: FileChannel = FileChannel.open(
		contentPath,
		StandardOpenOption.APPEND, StandardOpenOption.CREATE
	)
	val timestamp: FileChannel = FileChannel.open(
		timestampPath,
		StandardOpenOption.WRITE, StandardOpenOption.CREATE
	)
	val memoryBank = readMemoryBank(bank)
	private var closed = false
	var timeIndex = 0uL

	init {
		val timestampBacked = ByteBuffer.allocate(10)
		val timestampData = timestampBacked.array().inputStream()
		timeIndex = timestampData.readExtensibleULong()
		timestamp.position(10)
	}

	private fun bankedWord(string: String): ULong {
		if (!memoryBank.contains(string)) {
			memoryBank.add(string)
			val plaintext = string.toByteArray()
			val (array, compression) = huffmen.firstNotNullOfOrNull { (huffman, type) ->
				if (string.all { huffman.directMap.containsKey(it) }) {
					val huffmanOutBits = BitOutputStream(ByteArrayOutputStream())
					for (char in string) huffman.write(char, huffmanOutBits)
					val unused = huffmanOutBits.position % 7
					huffmanOutBits.flush()
					val huffmanOut = huffmanOutBits.to.toByteArray()
					if (huffmanOut.size < plaintext.size) huffmanOut to (type or (unused shl 5))
					else null
				} else null
			} ?: (plaintext to 0)
			val output = ByteArrayOutputStream()
			output.writeExtensibleULong(array.size.toULong())
			output.write(compression)
			output.write(array)
			bank.write(ByteBuffer.wrap(output.toByteArray()))
		}
		return memoryBank.indexOf(string).toULong()
	}

	var recentSeconds = 0uL
	private fun timestamp(seconds: ULong): ULong {
		if (recentSeconds != seconds) {
			recentSeconds = seconds
			timestamp.position(0)
			val idStream = ByteArrayOutputStream()
			idStream.writeExtensibleULong(timeIndex++)
			timestamp.write(ByteBuffer.wrap(idStream.toByteArray()))
			timestamp.position(timestamp.size().coerceAtLeast(10))
			val timeData = ByteArrayOutputStream()
			timeData.writeExtensibleULong(seconds)
			timestamp.write(ByteBuffer.wrap(timeData.toByteArray()))
		}
		return timeIndex - 1u
	}

	var recentNanos = 0
	private val breaker = BreakIterator.getWordInstance()
	private val specifiedLevelDetails = mutableSetOf<ULong>()
	private val writtenMessages = mutableListOf<String>()
	override fun publish(record: LogRecord) {
		if (closed) throw IllegalStateException("BankedFileHandler closed")
		val output = ByteArrayOutputStream()
		val timeIndex = timestamp(record.instant.epochSecond.toULong())
		output.writeExtensibleULong(timeIndex)
		val nanos = record.instant.nano
		output.writeExtensibleLong((nanos - recentNanos).toLong())
		recentNanos = nanos
		val bankedLevelName = bankedWord(record.level.name)
		if (specifiedLevelDetails.contains(bankedLevelName)) {
			output.writeExtensibleULong(bankedLevelName shl 1)
		} else {
			if (
				record.level.resourceBundleName != null &&
				try {
					ResourceBundle.getBundle(record.level.resourceBundleName).containsKey(record.level.name)
				} catch (_: MissingResourceException) {
					false
				}
			) {
				output.writeExtensibleULong((bankedWord(record.level.resourceBundleName) shl 1) or 1u)
				output.writeExtensibleULong(bankedLevelName)
			} else output.writeExtensibleULong(bankedLevelName shl 1)
			output.writeExtensibleLong(record.level.intValue().toLong())
			specifiedLevelDetails.add(bankedLevelName)
		}
		output.writeExtensibleULong(bankedWord(record.loggerName))
		output.writeExtensibleLong(record.longThreadID)
		val recordIndex = writtenMessages.indexOf(record.message)
		if (recordIndex == -1) {
			val broken = buildList {
				val alpha = Normalizer.normalize(record.message, Normalizer.Form.NFC)
				breaker.setText(alpha)
				var from = breaker.first()
				while (true) {
					val next = breaker.next()
					if (next == BreakIterator.DONE) break
					val word = alpha.substring(from..(next - 1))
					if (word.isNotBlank()) add(word)
					from = next
				}
			}
			output.writeExtensibleULong(broken.size.toULong() shl 1)
			broken.forEach { output.writeExtensibleULong(bankedWord(it)) }
			writtenMessages.add(record.message)
		} else output.writeExtensibleULong((recordIndex.toULong() shl 1) or 1u)
		content.write(ByteBuffer.wrap(output.toByteArray()))
	}

	override fun flush() {
		bank.force(false)
		content.force(false)
		timestamp.force(false)
	}

	override fun close() {
		this.flush()
		bank.close()
		content.close()
		timestamp.close()
		closed = true
	}
}